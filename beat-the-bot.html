<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Beat the Market â€” Matthieu Farbos</title>
    <meta name="description" content="Beat the Market â€” mini-jeu de trading simule (stop & take profit)." />
    <link rel="prefetch" href="index.html" />
    <link rel="prefetch" href="projets.html" />
    <style>
      :root { --panel-width: 360px; --edge: 8px; --gap: 8px; --chart-extra-right: 30px; --chart-extra-bottom: 10px; --v-gap: 10px; --v-gap-small: 6px; }
      html, body { height: 100%; margin: 0; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: #0a0e12; color: #fff; overflow: hidden; opacity: 0; transition: opacity .25s ease; }

      /* Layout */
      .overlay { position: relative; z-index: 10; height: 100dvh; display: block; padding: 0; }
      .chart-wrap { position: fixed; left: var(--edge); top: var(--edge); bottom: calc(56px + var(--chart-extra-bottom)); right: calc(var(--panel-width) + var(--edge) + var(--gap) + var(--chart-extra-right)); background: rgba(14,18,24,0.85); border: 1px solid rgba(255,255,255,0.1); border-radius: 14px; padding: 8px; box-shadow: 0 6px 24px rgba(0,0,0,0.35); }
      #chart { display: block; width: 100%; height: 100%; border-radius: 8px; }

      .panel { position: fixed; right: var(--edge); top: var(--edge); bottom: 56px; z-index: 26; width: var(--panel-width); display: flex; flex-direction: column; gap: 10px; overflow: auto; background: rgba(14,18,24,0.82); border: 1px solid rgba(255,255,255,0.12); padding: 10px 12px; border-radius: 12px; font-size: 14px; }
      .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
      .row.stack { display: grid; grid-template-columns: 1fr; gap: 4px; align-items: start; }
      .metric { margin-bottom: var(--v-gap); }
      .metric .label { opacity: .9; font-weight: 600; }
      .metric .value { font-weight: 700; font-size: 18px; }
      .stats { margin-bottom: var(--v-gap); }
      .stats .label { font-weight: 600; }
      .stats .value { font-weight: 700; }
      .stats .value div { margin-bottom: var(--v-gap-small); }
      .stats .value div:last-child { margin-bottom: 0; }
      .divider { height: 1px; background: rgba(255,255,255,0.18); margin: 8px 0; }
      .actions { display: flex; gap: 14px; align-items: center; justify-content: space-between; }
      .actions.cta { margin: 0 0 var(--v-gap); }
      .btn.big { padding: 14px 22px; font-size: 18px; font-weight: 700; border-radius: 14px; min-width: 130px; }
      .posline { text-align: center; opacity: .9; margin: 0 0 var(--v-gap); }
      .inputs.two { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: center; margin-bottom: var(--v-gap); }
      .field { display: grid; grid-template-columns: auto 1fr; gap: 8px; align-items: center; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; padding: 0 8px; min-height: 24px; }
      .field label { opacity: .9; line-height: 24px; }
      .field input[type="number"] { width: 100%; max-width: 100%; box-sizing: border-box; height: 22px; line-height: 22px; padding: 0 6px; border-radius: 6px; background: rgba(0,0,0,0.25); border: 1px solid rgba(255,255,255,0.2); color: #fff; font-size: 13px; }
      .inputs.single { display: grid; grid-template-columns: 1fr; gap: 10px; margin-bottom: var(--v-gap); }
      .levels-row { margin-bottom: var(--v-gap); }
      .panel > *:last-child { margin-bottom: 0; }
      .levels-row { display: grid; grid-template-columns: auto 1fr; gap: 8px; align-items: center; }
      .levels { display:inline-block; opacity:.85; font-size:12px; }

      .btn { padding: 10px 14px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.06); color: #fff; cursor: pointer; }
      .btn:hover { background: rgba(255,255,255,0.12); }
      .btn.buy { border-color: rgba(0,200,120,0.6); background: rgba(0,200,120,0.2); }
      .btn.buy:hover { background: rgba(0,200,120,0.3); }
      .btn.sell { border-color: rgba(240,80,80,0.6); background: rgba(240,80,80,0.2); }
      .btn.sell:hover { background: rgba(240,80,80,0.3); }
      .pos { opacity: .9; }

      .btn-back { position: fixed; top: 8px; left: 8px; z-index: 30; padding: 8px 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); color: #fff; text-decoration: none; background: rgba(255,255,255,0.06); }
      .btn-back:hover { background: rgba(255,255,255,0.12); }

      /* .credit-name removed */

      .footer { position: fixed; left: 0; right: 0; bottom: 0; z-index: 20; display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 14px; background: rgba(10,14,18,0.72); border-top: 1px solid rgba(255,255,255,0.08); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); font-size: 14px; }
      .footer .links { display: flex; gap: 16px; align-items: center; }
      .footer a { color: #fff; text-decoration: none; opacity: 0.9; }
      .footer a:hover { opacity: 1; text-decoration: underline; }
      .footer .lang { display: flex; align-items: center; gap: 8px; }
      .footer .lang label { opacity: 0.8; }
      .footer .lang button { appearance: none; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.06); color: #fff; padding: 6px 10px; border-radius: 8px; cursor: pointer; font-size: 13px; }
      .footer .lang button:hover { background: rgba(255,255,255,0.12); }
      .footer .lang button.active { background: rgba(66,133,244,0.35); border-color: rgba(66,133,244,0.6); }

      /* Mobile layout: panel as bottom drawer, chart above */
      @media (max-width: 640px) {
        :root { --mobile-panel-h: 44vh; }
        .chart-wrap { left: var(--edge); right: var(--edge); top: var(--edge); bottom: calc(56px + var(--mobile-panel-h) + var(--gap)); }
        .panel { left: var(--edge); right: var(--edge); width: auto; top: auto; bottom: 56px; height: var(--mobile-panel-h); }
        .btn.big { padding: 12px 18px; font-size: 16px; border-radius: 12px; }
        .field { min-height: 34px; }
        .field label { line-height: 34px; }
        .field input[type="number"] { height: 32px; line-height: 32px; font-size: 16px; }
      }
    </style>
  </head>
  <body>
    <div id="bg"></div>

    <main class="overlay">
      <div class="chart-wrap"><canvas id="chart"></canvas></div>

      <div class="panel" id="panel">
        <a class="btn-back" href="projets.html" id="back-link">&larr; Retour aux projets</a>
        <div class="metric row stack"><span class="label" id="lbl-equity-2">Equite</span><span class="value" id="equity">-</span></div>
        <div class="metric row stack"><span class="label" id="lbl-unreal-2">PNL latent</span><span class="value" id="unrealized">-</span></div>
        <div class="stats row stack" id="stats-row">
          <span class="label" id="lbl-stats">Stats</span>
          <div>
            <div>Winrate: <span id="stat-win">0</span>%</div>
            <div>Longs: <span id="stat-longs">0</span></div>
            <div>Shorts: <span id="stat-shorts">0</span></div>
          </div>
        </div>
        <div class="divider"></div>
        <div class="actions cta">
          <button id="buy" class="btn buy big">Acheter</button>
          <button id="sell" class="btn sell big">Vendre</button>
        </div>
        <div class="posline" id="posline">Flat @ -</div>
        <div class="inputs two">
          <div class="field"><label for="tpPct" id="lbl-tp">TP (%)</label><input type="number" id="tpPct" min="0" step="0.1" inputmode="decimal" value="4" /></div>
          <div class="field"><label for="stopPct" id="lbl-stop">Stop (%)</label><input type="number" id="stopPct" min="0" step="0.1" inputmode="decimal" value="2" /></div>
        </div>
        <div class="inputs single">
          <div class="field"><label for="qty" id="lbl-qty">Quantite</label><input type="number" id="qty" min="1" step="1" inputmode="numeric" value="1" /></div>
        </div>
        <div class="levels-row"><label>Niveaux</label><span class="levels" id="levels">SL: - | TP: -</span></div>
      </div>
    </main>

    

    <nav class="footer" aria-label="Navigation bas de page">
      <div class="links">
        <a href="index.html" id="nav-home">Accueil</a>
        <a href="projets.html" id="nav-projects">Projets</a>
      </div>
      <div class="lang" role="group" aria-label="Choix de langue">
        <label>Langue:</label>
        <button type="button" data-lang="fr" aria-pressed="false" id="btn-fr">FR</button>
        <button type="button" data-lang="en" aria-pressed="false" id="btn-en">EN</button>
      </div>
    </nav>

    <script>
      // Transitions
      function setupTransitions() {
        requestAnimationFrame(() => { document.body.style.opacity = '1'; });
        document.querySelectorAll('a[href]').forEach(a => {
          const href = a.getAttribute('href');
          if (!href || href.startsWith('http') || href.startsWith('#') || a.target === '_blank') return;
          a.addEventListener('click', (e) => { e.preventDefault(); document.body.style.opacity = '0'; setTimeout(() => { window.location.href = a.href; }, 200); });
        });
      }

      // Lang
      const storageKey = 'site.lang';
      let currentLang = (localStorage.getItem(storageKey) || 'fr');
      function setActiveButtons() {
        const frBtn = document.getElementById('btn-fr');
        const enBtn = document.getElementById('btn-en');
        frBtn.classList.toggle('active', currentLang === 'fr');
        enBtn.classList.toggle('active', currentLang === 'en');
        frBtn.setAttribute('aria-pressed', String(currentLang === 'fr'));
        enBtn.setAttribute('aria-pressed', String(currentLang === 'en'));
      }
      function applyLanguage(lang) {
        currentLang = (lang === 'en') ? 'en' : 'fr';
        localStorage.setItem(storageKey, currentLang);
        setActiveButtons();
        const navHome = document.getElementById('nav-home');
        const navProjects = document.getElementById('nav-projects');
        const langLabel = document.querySelector('.lang label');
        const lQty = document.getElementById('lbl-qty');
        const lStop = document.getElementById('lbl-stop');
        const lTp = document.getElementById('lbl-tp');
        const lEquity = document.getElementById('lbl-equity-2');
        const lUnreal = document.getElementById('lbl-unreal-2');
        if (currentLang === 'fr') {
          navHome.textContent = 'Accueil'; navProjects.textContent = 'Projets'; langLabel.textContent = 'Langue:';
          lQty.textContent = 'Quantite'; lStop.textContent = 'Stop (%)'; lTp.textContent = 'TP (%)';
          lEquity.textContent = 'Equite'; lUnreal.textContent = 'PNL latent';
        } else {
          navHome.textContent = 'Home'; navProjects.textContent = 'Projects'; langLabel.textContent = 'Language:';
          lQty.textContent = 'Quantity'; lStop.textContent = 'Stop (%)'; lTp.textContent = 'Take Profit (%)';
          lEquity.textContent = 'Equity'; lUnreal.textContent = 'Unrealized PnL';
        }
      }

      // Simulation + PnL + Stops/TP
      const state = { price: 100, position: 0, avg: 0, cash: 50000, realized: 0, stopPx: null, tpPx: null };
      let tradeSide = null; // 'long' | 'short'
      let tradesTotal = 0, tradesWins = 0, tradesLong = 0, tradesShort = 0;
      const candles = [];
      const TF = 5000; // 5s per candle
  let lastCandleTime = 0;

      // Seed historical candles so the chart starts populated
      function seedCandles(n) {
        try { n = Math.max(1, Math.floor(n)); } catch { n = 30; }
        const now = Date.now();
        candles.length = 0;
        let p = state.price;
        let t = now - (n - 1) * TF;
        let prevClose = p;
        for (let i = 0; i < n; i++) {
          const o = prevClose;
          let h = o, l = o;
          // Simulate intra-candle movement with a few sub-steps
          for (let j = 0; j < 5; j++) {
            p = nextPrice(p);
            if (p > h) h = p;
            if (p < l) l = p;
          }
          const c = p;
          candles.push({ t, o, h, l, c });
          prevClose = c;
          t += TF;
        }
        state.price = prevClose;
        lastCandleTime = now; // last seeded candle is "now"
        draw();
        updateHud();
      }

      function getPercents() {
        const sp = parseFloat(document.getElementById('stopPct').value || '0');
        const tp = parseFloat(document.getElementById('tpPct').value || '0');
        return { sp: Math.max(0, sp), tp: Math.max(0, tp) };
      }
      function recalcStops() {
        if (state.position === 0 || !state.avg) { state.stopPx = null; state.tpPx = null; updateLevels(); return; }
        const { sp, tp } = getPercents();
        const avg = state.avg;
        if (state.position > 0) { state.stopPx = sp ? avg * (1 - sp/100) : null; state.tpPx = tp ? avg * (1 + tp/100) : null; }
        else { state.stopPx = sp ? avg * (1 + sp/100) : null; state.tpPx = tp ? avg * (1 - tp/100) : null; }
        updateLevels();
      }
      function updateLevels() {
        const el = document.getElementById('levels');
        const sl = state.stopPx ? state.stopPx.toFixed(2) : '-';
        const tp = state.tpPx ? state.tpPx.toFixed(2) : '-';
        el.textContent = `SL: ${sl} | TP: ${tp}`;
      }

      function nextPrice(p) {
        const vol = 2.0 + Math.random() * 1.5; // 2.0..3.5
        const drift = (Math.random() - 0.5) * vol;
        const revert = (100 - p) * 0.0015;
        let np = p + drift + revert;
        if (Math.random() < 0.06) np += (Math.random() - 0.5) * 8; // jump
        return Math.max(1, np);
      }

      function tick() {
        state.price = nextPrice(state.price);
        const now = Date.now();
        if (!candles.length || now - lastCandleTime >= TF) {
          const o = candles.length ? candles[candles.length - 1].c : state.price;
          // Keep at most 80 candles visible: drop oldest before adding the new one
          if (candles.length >= 80) { candles.shift(); }
          candles.push({ t: now, o, h: state.price, l: state.price, c: state.price });
          lastCandleTime = now;
        } else {
          const k = candles[candles.length - 1];
          k.c = state.price; k.h = Math.max(k.h, state.price); k.l = Math.min(k.l, state.price);
        }
        checkStops(); draw(); updateHud();
      }

      function closeAll(px) {
        if (state.position === 0) return;
        const qty = Math.abs(state.position);
        const before = state.realized;
        if (state.position > 0) { state.realized += qty * (px - state.avg); state.cash += px * qty; }
        else { state.realized += qty * (state.avg - px); state.cash -= px * qty; }
        state.position = 0; state.avg = 0; state.stopPx = null; state.tpPx = null; updateLevels();
        const pnl = state.realized - before; recordTrade(tradeSide, pnl);
      }
      function checkStops() {
        if (state.position === 0) return; const px = state.price;
        if (state.position > 0) { if (state.stopPx && px <= state.stopPx) return closeAll(px); if (state.tpPx && px >= state.tpPx) return closeAll(px); }
        else { if (state.stopPx && px >= state.stopPx) return closeAll(px); if (state.tpPx && px <= state.tpPx) return closeAll(px); }
      }

      function formatMoney(x) {
        try { return (currentLang === 'fr' ? x.toLocaleString('fr-FR', { style: 'currency', currency: 'EUR' }) : x.toLocaleString('en-US', { style: 'currency', currency: 'USD' })); }
        catch { return x.toFixed(2); }
      }
      function updateHud() {
        const unreal = state.position * (state.price - state.avg);
        const equity = state.cash + state.realized + unreal;
        const elUnr = document.getElementById('unrealized'); if (elUnr) elUnr.textContent = formatMoney(unreal);
        const elEq = document.getElementById('equity'); if (elEq) elEq.textContent = formatMoney(equity);
        const qty = Math.abs(state.position);
        const dir = state.position > 0 ? 'Long' : state.position < 0 ? 'Short' : 'Flat';
        const txt = `${dir} ${qty || ''} @ ${state.avg ? state.avg.toFixed(2) : state.price.toFixed(2)}`;
        const posEl = document.getElementById('pos'); if (posEl) posEl.textContent = txt;
        const posLine = document.getElementById('posline'); if (posLine) posLine.textContent = txt;
      }
      function updateStats() {
        const winrate = tradesTotal ? Math.round((tradesWins / tradesTotal) * 100) : 0;
        const w = document.getElementById('stat-win'); if (w) w.textContent = String(winrate);
        const lg = document.getElementById('stat-longs'); if (lg) lg.textContent = String(tradesLong);
        const sh = document.getElementById('stat-shorts'); if (sh) sh.textContent = String(tradesShort);
      }
      function recordTrade(side, pnl) {
        tradesTotal += 1; if (pnl > 0) tradesWins += 1; if (side === 'long') tradesLong += 1; else if (side === 'short') tradesShort += 1; tradeSide = null; updateStats();
      }
      function placeOrder(side, qty) {
        qty = Math.max(1, Math.floor(qty)); const px = state.price; const prevPos = state.position;
        if (side === 'buy') {
          if (state.position >= 0) { const newPos = state.position + qty; state.avg = (state.avg * state.position + px * qty) / (newPos || 1); state.position = newPos; state.cash -= px * qty; }
          else { const closeQty = Math.min(qty, -state.position); const before = state.realized; state.realized += closeQty * (state.avg - px); state.position += closeQty; state.cash -= px * closeQty; const rem = qty - closeQty; if (rem > 0) { state.avg = px; state.position += rem; state.cash -= px * rem; } else if (state.position === 0) { state.avg = 0; } if (state.position === 0) { recordTrade('short', state.realized - before); } }
        } else {
          if (state.position <= 0) { const newPos = state.position - qty; state.avg = (Math.abs(state.avg * state.position) + px * qty) / (Math.abs(newPos) || 1); state.position = newPos; state.cash += px * qty; }
          else { const closeQty = Math.min(qty, state.position); const before = state.realized; state.realized += closeQty * (px - state.avg); state.position -= closeQty; state.cash += px * closeQty; const rem = qty - closeQty; if (rem > 0) { state.avg = px; state.position -= rem; state.cash += px * rem; } else if (state.position === 0) { state.avg = 0; } if (state.position === 0) { recordTrade('long', state.realized - before); } }
        }
        if (prevPos === 0 && state.position !== 0) { tradeSide = state.position > 0 ? 'long' : 'short'; }
        recalcStops(); updateHud();
      }

      // Chart
      const canvas = document.getElementById('chart');
      const ctx = canvas.getContext('2d');
      function resize() {
        const wrap = document.querySelector('.chart-wrap');
        const dpr = Math.min(2, window.devicePixelRatio || 1);
        const w = Math.max(0, Math.floor(wrap.clientWidth));
        const h = Math.max(0, Math.floor(wrap.clientHeight));
        canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
        canvas.width = Math.floor(w * dpr); canvas.height = Math.floor(h * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0); draw();
      }
      function draw() {
        const w = canvas.clientWidth; const h = canvas.clientHeight; ctx.clearRect(0,0,w,h);
        // plot area (reserve right axis)
        const axisW = (window.innerWidth <= 640 ? 44 : 56);
        const plotL = 0; const plotR = Math.max(0, w - axisW); const plotW = Math.max(0, plotR - plotL);
        ctx.fillStyle = 'rgba(14,18,24,0.9)'; ctx.fillRect(0,0,w,h);
        // grid lines within plot area
        ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1; for (let i=1;i<6;i++){ const gy=(h/6)*i; ctx.beginPath(); ctx.moveTo(plotL,gy); ctx.lineTo(plotR,gy); ctx.stroke(); }
        const visible = Math.min(candles.length, 80); const start = Math.max(0, candles.length - visible); const view = candles.slice(start); if (!view.length) return;
        let min = Infinity, max = -Infinity; for (const k of view){ if (k.l < min) min = k.l; if (k.h > max) max = k.h; } const pad = (max-min)*0.1 || 1; min -= pad; max += pad;
        const y = v => h - (v - min) / (max - min) * h;
        const gap = 2; const xw = Math.max(3, Math.floor(plotW / (view.length + 1)) - gap);
        view.forEach((k,i)=>{ const x = plotL + i * (xw + gap) + gap; const up = k.c >= k.o; const color = up ? 'rgba(0,200,120,0.9)' : 'rgba(240,80,80,0.9)'; ctx.strokeStyle = color; ctx.fillStyle = color; // wick
          ctx.beginPath(); ctx.moveTo(x + xw/2, y(k.h)); ctx.lineTo(x + xw/2, y(k.l)); ctx.stroke(); // body
          const y1=y(k.o), y2=y(k.c); const top=Math.min(y1,y2), bh=Math.max(2, Math.abs(y1-y2)); ctx.fillRect(x, top, xw, bh); });
        // last price line within plot area
        const lp = state.price; const ly = y(lp); ctx.strokeStyle = 'rgba(77,163,255,0.4)'; ctx.setLineDash([6,6]); ctx.beginPath(); ctx.moveTo(plotL, ly); ctx.lineTo(plotR, ly); ctx.stroke(); ctx.setLineDash([]);
        // stop/tp lines
        if (state.position !== 0) {
          if (state.stopPx) { ctx.strokeStyle = 'rgba(240,80,80,0.6)'; ctx.setLineDash([4,6]); const sy = y(state.stopPx); ctx.beginPath(); ctx.moveTo(plotL, sy); ctx.lineTo(plotR, sy); ctx.stroke(); ctx.setLineDash([]); }
          if (state.tpPx) { ctx.strokeStyle = 'rgba(0,200,120,0.6)'; ctx.setLineDash([4,6]); const ty = y(state.tpPx); ctx.beginPath(); ctx.moveTo(plotL, ty); ctx.lineTo(plotR, ty); ctx.stroke(); ctx.setLineDash([]); }
        }
        // Right price axis (ticks every 10 units)
        ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(plotR+0.5, 0); ctx.lineTo(plotR+0.5, h); ctx.stroke();
        ctx.fillStyle = 'rgba(220,230,255,0.9)'; ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
        const STEP = 10; const startVal = Math.floor(min / STEP) * STEP; const endVal = Math.ceil(max / STEP) * STEP;
        for (let val = startVal; val <= endVal; val += STEP) {
          const tyc = y(val);
          ctx.beginPath(); ctx.moveTo(plotR, tyc); ctx.lineTo(plotR+6, tyc); ctx.stroke();
          ctx.fillText(Number.isInteger(val) ? val.toFixed(0) : val.toFixed(2), plotR + 8, tyc);
        }
        // Last price label
        ctx.fillStyle = 'rgba(77,163,255,0.9)'; ctx.fillText(lp.toFixed(2), plotR + 8, ly);
      }

      document.getElementById('buy').addEventListener('click', () => { const qty = parseInt(document.getElementById('qty').value || '1', 10); placeOrder('buy', qty); });
      document.getElementById('sell').addEventListener('click', () => { const qty = parseInt(document.getElementById('qty').value || '1', 10); placeOrder('sell', qty); });
      // Secondary buttons removed
      document.getElementById('stopPct').addEventListener('input', recalcStops);
      document.getElementById('tpPct').addEventListener('input', recalcStops);

      window.addEventListener('resize', resize);
      window.addEventListener('DOMContentLoaded', function() {
        setupTransitions(); setActiveButtons(); applyLanguage(currentLang); updateStats(); resize();
        seedCandles(80); // start with 80 historical candles
        setInterval(tick, 400);
      });
    </script>
  </body>
  </html>


